<!DOCTYPE html>
<html><head><meta property="og:type" content="website">
<meta property="og:url" content="http://localhost:3000/blog/-arch-nuc-install/">
<meta name="twitter:card" content="summary">
</head><body><p>{{% notice title="⚰️ Is this up to date?" %}}
While I used to fiddle with Arch, and other Linux distros when I was younger, I don't run it as my daily driver nowadays.</p>
<p>If I were to reinstall Arch Linux tomorrow, I would still dogfood my own guide and expect that it should be fairly seemless.</p>
<p {%="" notice="" %="">While I don't expect much has changed, you should know that I'm not actively verifying that these steps haven't changed or anything like that.</p>
<p>It's that time again where I decide to reinstall Arch Linux and likely end up bashing my head against a wall. I have an old blog post on my Github but it could be better so this is an extended version mainly for my own future reference.</p>
<p>Please note that this isn't some guide for pros or that I expect to have the most 100% correct or efficient method of installing. It's just what I know works for me.</p>
<h2>Getting online</h2>
<p>As I'm installing on an Intel NUC, I'm going to assume you might like it run it mainly via WiFi so we'll start by getting online. You can do this graphically by running <code>wifi-menu</code>.</p>
<pre><code class="language-bash hljs">wifi-menu
</code></pre>
<p>Once you've set up a profile, you'll see a new entry when using the <code>ifconfig</code> command and you can confirm you're online with <code>ping archlinux.org -c 3</code>.</p>
<h2>Setting up your hard drive</h2>
<p>Personally, I wouldn't, and probably couldn't (yet) install Arch Linux as a dual boot partition. That is, alongside another operating system such as Windows or macOS. You might like to and that's great but this isn't the guide for you :)</p>
<p>First, we need to see what our current devices are:</p>
<pre><code class="language-bash hljs">fdisk -l
</code></pre>
<p>You may see a few. In my case, my hard drive has a few <code>/dev/sda&lt;number&gt;</code> entries and my USB has 2 <code>/dev/sdb&lt;number&gt;</code> entries. For the purposes of this guide, I'll be assuming that your hard drive is under <code>/dev/sda</code> but when installing to, say, a Macbook, I've found that the hard drive can be under <code>/dev/sdb</code>.</p>
<p>My hard drive will end up looking as follows once I've set it up:</p>
<table>
<thead>
<tr>
<th>SIZE</th>
<th>PURPOSE</th>
<th>LOCATION</th>
</tr>
</thead>
<tbody>
<tr>
<td>500M</td>
<td>Boot Sector</td>
<td>/boot</td>
</tr>
<tr>
<td>20G</td>
<td>System Root</td>
<td>/</td>
</tr>
<tr>
<td>8G</td>
<td>Swap Space</td>
<td>N/A</td>
</tr>
<tr>
<td>437G</td>
<td>Home Directory</td>
<td>/home</td>
</tr>
</tbody>
</table>
<p>I'm targeting a <a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a> BIOS so we'll be using <a href="https://en.wikipedia.org/wiki/GUID_Partition_Table">GPT</a> for our partition table.</p>
<p>The following uses <a href="https://www.gnu.org/software/parted/manual/parted.html">gparted</a> which you may or may not be familiar with if you've only use GUI installers before. Just follow along and I'll comment what each segment is roughly doing. From hereon in, URLs prefixed by a tilde (~) indicate resources where you can read further information if you're the curious sort.</p>
<p {%="" notice="" %="">{{% notice emoji="⚠️" title="Consider yourself warned" %}}
The following <em>WILL</em> wipe your hard drive so ensure that this is what you'd like to do and/or that you've backed up everything from any currently installed OS</p>
<h2>Partitioning</h2>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Launched parted, passing our hard drive as an argument</span>
parted /dev/sda

<span class="hljs-comment"># Create a partition table using the GUID Partition Table (GPT) format.</span>
<span class="hljs-comment"># This wipes your drive(!)</span>
mklabel gpt

<span class="hljs-comment"># Create a 499M boot sector that will live at /boot</span>
<span class="hljs-comment"># ESP is short for EFI System Partition and are always formatted as FAT32</span>
<span class="hljs-comment"># We start at 1MiB instead of 0 because MBR/GPT both use the first block</span>
<span class="hljs-comment"># ~ https://unix.stackexchange.com/a/286325</span>
<span class="hljs-comment"># We use 550MiB as Rod Smith reports possible bugs with ESPs below 512MiB</span>
<span class="hljs-comment"># ~ http://www.rodsbooks.com/efi-bootloaders/principles.html</span>
mkpart ESP fat32 1MiB 551MiB

<span class="hljs-comment"># Set the boot flag to ON on partition number 1</span>
<span class="hljs-comment"># ~ https://www.gnu.org/software/parted/manual/html_node/set.html</span>
<span class="hljs-built_in">set</span> 1 boot on

<span class="hljs-comment"># Create a 20G ext4 partition that will live at /</span>
mkpart primary ext4 551MiB 20.5GiB

<span class="hljs-comment"># Create an 8G swap partition</span>
mkpart primary linux-swap 20.5GiB 28.5GiB

<span class="hljs-comment"># Allocate the remaining space which will be used by users at /home/{user}</span>
mkpart primary 28.5GiB 100%

<span class="hljs-comment"># All done!</span>
quit
</code></pre>
<p>Now that are partitions are set up, running <code>fdisk -l</code> again should show the following:</p>
<table>
<thead>
<tr>
<th>DEVICE</th>
<th>FORMAT</th>
<th>LOCATION</th>
</tr>
</thead>
<tbody>
<tr>
<td>/dev/sda1</td>
<td>ESP</td>
<td>/boot</td>
</tr>
<tr>
<td>/dev/sda2</td>
<td>ext4</td>
<td>/</td>
</tr>
<tr>
<td>/dev/sda4</td>
<td>ext4</td>
<td>/home</td>
</tr>
</tbody>
</table>
<h2>Making file systems</h2>
<p>We don't need any utilites to create our file systems, we can just do 'em straight outta the box like so:</p>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Create a 32bit VFAT filesystem for our boot partition</span>
<span class="hljs-comment"># VFAT is essentially FAT32 with support for longer filenames. See below for more details.</span>
<span class="hljs-comment"># ~ http://wiki.linuxquestions.org/wiki/VFAT</span>
<span class="hljs-comment"># ~ https://unix.stackexchange.com/a/263731</span>
mkfs.vfat -F32 /dev/sda1

<span class="hljs-comment"># Create an ext4 filesystem for our root partition</span>
mkfs.ext4 /dev/sda2

<span class="hljs-comment"># Prepare a swap area</span>
mkswap /dev/sda3

<span class="hljs-comment"># Activate our created swap area</span>
swapon /dev/sda3

<span class="hljs-comment"># Create an ext4 filesystem for our home partition</span>
mkfs.ext4 /dev/sda4
</code></pre>
<p>Now that our hard drive is completely set up, we're ready to mount our file systems.</p>
<h2>Mounting our new file systems</h2>
<p>Just as a reminder, here's where we want our partitions to end up</p>
<table>
<thead>
<tr>
<th>DEVICE</th>
<th>FORMAT</th>
<th>LOCATION</th>
</tr>
</thead>
<tbody>
<tr>
<td>/dev/sda1</td>
<td>ESP</td>
<td>/boot</td>
</tr>
<tr>
<td>/dev/sda2</td>
<td>ext4</td>
<td>/</td>
</tr>
<tr>
<td>/dev/sda4</td>
<td>ext4</td>
<td>/home</td>
</tr>
</tbody>
</table>
<p>Here's how this layout translates into mount commands:</p>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Mount our root partition to /mnt</span>
<span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> /mnt doesn't persist once we're in our bash prompt</span>
<span class="hljs-comment"># For example, /mnt/home becomes just /home</span>
mount /dev/sda2 /mnt

<span class="hljs-comment"># Create a folder which our ESP partition will be mounted to</span>
<span class="hljs-built_in">mkdir</span> /mnt/boot

<span class="hljs-comment"># Mount our ESP partition to /boot</span>
mount /dev/sda1 /mnt/boot

<span class="hljs-comment"># Create a home folder where all of our user directories will live</span>
<span class="hljs-built_in">mkdir</span> /mnt/home

<span class="hljs-comment"># Mount the home partition to /home</span>
mount /dev/sda4 /mnt/home
</code></pre>
<p>Nice! We're completely done and can start to actually install and configure Arch Linux.</p>
<h2>Installing base packages</h2>
<p>Now we need to download and install the base packages for Arch Linux to our <code>/mnt</code> which will becomes our root (<code>/</code>) later on.</p>
<pre><code class="language-bash hljs">pacstrap /mnt base
</code></pre>
<p>For the curious, the <code>base</code> group contains a number of default libraries and utilties you may have used such as <code>man</code>, <code>openssl</code>, <code>bash</code>, <code>iptables</code> and <code>gcc</code> to name a few.</p>
<p>You can view the <code>pacstrap</code> script itself <a href="https://git.archlinux.org/arch-install-scripts.git/tree/pacstrap.in">here</a>. I thought it would be quite longer!</p>
<p>The script also runs the <code>mkinitcpio</code> bash script which you can learn more about <a href="https://wiki.archlinux.org/index.php/mkinitcpio#Overview">here</a>.</p>
<p>This entire process may take a few minutes so feel free to read ahead while you wait.</p>
<h2>Set up bash</h2>
<p>With Arch Linux installed, we can finally move off of our live USB and start a bash process to set up our freshly initialised system after 2 more quick steps</p>
<p>Step 1 is generating a <a href="http://www.linfo.org/etc_fstab.html">file systems table</a>, referred to as <code>fstab</code> going forward. This is done so that all devices (/dev/sdaX) specificied in the file are mounted automatically on startup.</p>
<pre><code class="language-bash hljs">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab
</code></pre>
<p>The <code>-U</code> flag denotes that we want to identify our devices using <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUIDs</a>, instead of labels, as noted <a href="https://github.com/falconindy/arch-install-scripts/blob/master/genfstab.in#L86">here</a>.</p>
<p>Step 2 is even quicker!</p>
<pre><code class="language-bash hljs">arch-chroot /mnt
</code></pre>
<p><code>arch-chroot</code>, seen <a href="https://github.com/falconindy/arch-install-scripts/blob/master/arch-chroot.in">here</a> changes the root directory to, well, <code>/</code> which is our new root directory. As we're still on the live USB, we specify it as <code>/mnt</code> instead.</p>
<p><code>arch-chroot</code> is also able to take some flags following the root partition such as <code>arch-chroot /mnt /bin/bash</code>. It's worth noting that the preceeding example is actually fairly pointless seeing as <code>arch-chroot</code> already defaults to <code>bash</code> anyway.</p>
<p>Huzzah! We're finally in our new system but will it boot? Not quite yet and we've still a lot to set up so let's carry on.</p>
<h2>Updates and other dependencies (optional)</h2>
<p>At this point, I like to run a system upgrade using <code>pacman -Syu</code> just in case. As we've just pulled our dependencies minutes ago, it'll likely find nothing but I reckon it feels good, haha.</p>
<p>I also need some extra bits and pieces for later at this point. We couldn't have fetched these earlier as trying to run <code>pacman</code>, the Arch Linux package manager, from the live USB would attempt to install to the USB itself and error out.</p>
<p>I need the following bits:</p>
<table>
<thead>
<tr>
<th>PACKAGE</th>
<th>PURPOSE</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://invisible-island.net/dialog/">dialog</a></td>
<td>A library for console-based UIs like <code>wifi-menu</code></td>
</tr>
<tr>
<td><a href="https://downloadcenter.intel.com/search?keyword=microcode+data">intel-ucode</a></td>
<td>Micro-code updates for Intel CPUs</td>
</tr>
<tr>
<td><a href="https://w1.fi/wpa_supplicant/">wpa_supplicant</a></td>
<td>Used to connect to wireless networks (put simply)</td>
</tr>
</tbody>
</table>
<p>That should be everything for now. The other bits (<code>netctl</code> and <code>dhcpcd</code>) were already installed as part of the <code>base</code> group from earlier. If you're using Ethernet, you can basically skip this entire step hence why it's marked as optional.</p>
<p>Honestly, we don't really need <code>dialog</code> as we could just use <code>netctl</code> directly but I find it more user friendly and I'm not a masochist, haha.</p>
<p>You might as well also enable <code>dhcpcd</code> if you need it for ethernet with <code>systemctl enable dhcpcd</code>.</p>
<h2>Generating locale</h2>
<p>Popular software often ships in a number of languages but in order to show the correct language, currency and so on, it needs to know where you live. We achieve this by generating and setting a locale.</p>
<p>To do so, edit <code>/etc/locale.gen</code> and uncomment your respective locale. In short, the format is <code>{language}_{country code}.{character encoding}</code>. As an example, I'm in New Zealand so I uncomment the line <code>en_NZ.UTF-8 UTF-8</code>. If in doubt, just opt for <code>utf-8</code>.</p>
<p>I just use <code>nano</code> but if you prefer, this would be an alright time to run <code>pacman -S vim</code>.</p>
<p>Once you've done that, you'll need to generate the locale files and export your language to your environment</p>
<pre><code class="language-bash hljs">locale-gen
<span class="hljs-built_in">export</span> LANG={xx}_{yy}.UTF-8
</code></pre>
<p>If done successfully, <code>echo $LANG</code> will display your locale.</p>
<p>For reference, the actual <code>locale-gen</code> script can be seen <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=localedata/gen-locale.sh;h=39f1475cbc45faaae32728dbfd7cce282c3cdb05;hb=HEAD">here</a> as part of <a href="https://sourceware.org/git/?p=glibc.git;a=summary">glibc</a>, the GNU implementation of the C standard library. I always wondered where it was from!</p>
<h2>Timezone</h2>
<p>Selecting our timezone is fairly straightforward thanks to an interactive program called <code>tzselect</code>. Running it will show a list of continents and oceans. Selecting one will drill down to display countries.</p>
<p>Once you've confirmed the output, it will mention appending the timezone to a file. Instead, we want to symlink that timezone to a file. In my case, the timezone is <code>Pacific/Auckland</code> but of course, you'll want to input your respective timezone instead.</p>
<pre><code class="language-bash hljs"><span class="hljs-built_in">ln</span> -s /usr/share/zoneinfo/Pacific/Auckland /etc/localtime
</code></pre>
<h2>Setting hardware clock</h2>
<p>The last of our locale related setups is configuring the system clock. To do that, we'll tell our hardware clock to set the system time using the <code>--hctosys</code> option. You can read more about <code>hwclock</code> and how it differs from system time <a href="https://linux.die.net/man/8/hwclock">here</a></p>
<pre><code class="language-bash hljs">hwclock --systohc
</code></pre>
<h2>Hostname setup</h2>
<p>We like life to be simple (but no simpler) and giving our computer/server a unique name is an important part of that process. For this bit, let's assume we want to name our system <code>weinerdog</code> because it sounds silly.</p>
<pre><code class="language-bash hljs"><span class="hljs-built_in">echo</span> weinerdog &gt; /etc/hostname
</code></pre>
<p>Oh, that was easy. We also need to tell our system that <code>weinerdog</code> is an alias for <code>127.0.0.1</code>, just like <code>localhost</code> is. We could fire up our favourite editor but it's likely <code>/etc/hosts</code> is empty so just do the following:</p>
<pre><code class="language-bash hljs"><span class="hljs-built_in">echo</span> 127.0.0.1 localhost weinerdog &gt; /etc/hosts
</code></pre>
<p>How quick was that, huh?</p>
<h2>Set a root password</h2>
<p>We'll be using this password to login, which I sometimes forget. It should be different than the password for the user account we'll be making soon but I'd be lying if I said I have a super secure password. You have bigger problems if you think this writeup will give you top notch security anyway. I'm just here for a usable system!</p>
<pre><code class="language-bash hljs">passwd
</code></pre>
<p>Just type in your password twice. Not much more to it than that.</p>
<h2>Installing a boot manager</h2>
<p>We'll be using <code>systemd-boot</code> as our EFI boot manager. I couldn't tell you anything about it other than it works and that's good enough.</p>
<pre><code class="language-bash hljs">bootctl --path=/boot install
</code></pre>
<p>The above command copies the <code>systemd-boot</code> binary to our EFI System Partition (<code>/boot</code>) and adds it as the default EFI application to be loaded as stated <a href="https://wiki.archlinux.org/index.php/systemd-boot#EFI_boot">here</a>.</p>
<h2>Configuring the boot manager</h2>
<p>Now that we have a boot manager, we need to tell it what to boot exactly. We'll create a new <code>arch.conf</code> entry using <code>nano</code>:</p>
<pre><code class="language-bash hljs">nano /boot/loader/entries/arch.conf
</code></pre>
<p>and enter the following</p>
<pre><code class="language-bash hljs">title Arch Linux
linux /vmlinuz-linux
initrd /intel-ucode.img
initrd /initramfs-linux.img
options root=/dev/sda2 rw elevator=deadline quiet splash resume=/dev/sda3 nmi_watchdog=0
</code></pre>
<p><strong>NOTE</strong>: The line <code>initrd /intel-ucode.img</code> <strong>ONLY</strong> applies if you installed the <code>intel-ucode</code> package from earlier which anyone with an Intel CPU should do.</p>
<p>As for the options, I couldn't say if you need, or don't need, any of them but it's worked fine for me so far. I'll probably read up on them in depth shortly and update this post as required.</p>
<p>Once that's created, set it as the default configuration:</p>
<pre><code class="language-bash hljs"><span class="hljs-built_in">echo</span> <span class="hljs-string">"default arch"</span> &gt; /boot/loader/loader.conf
</code></pre>
<p>and now you're ready to reboot into a nicely working system!</p>
<pre><code class="language-bash hljs"><span class="hljs-built_in">exit</span>
reboot
</code></pre>
<p>I've still got a lot to learn about Arch Linux but so far, the above setup has worked well for me.</p>
<p>There's still more that goes into a system but this is enough to get past the pesky initial setup which gave me hours upon hours of grief as a beginner, which I still am essentially.</p>
</body></html>