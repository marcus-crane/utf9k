#+HUGO_BASE_DIR: ../../
#+HUGO_SECTION: blog

* Blog

** Setting up Emacs inside of a WSL2 distribution :emacs:linux:unix:windows:wsl:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs-wsl2-install
:EXPORT_DATE: 2020-05-06
:END:

I've never really dedicated myself to Emacs despite being interested in [[https://orgmode.org/][org mode]] for a little while now.

One barrier to entry is that I had no idea how to install it on my desktop. The more places I have it installed, the quicker I can get comfortable enough to actually use it in my day to day life.

In particular, I'm trying out [[https://github.com/hlissner/doom-emacs][Doom Emacs]], a lightweight configuration that uses vim-style bindings.

I'm not much of a Vimmer either for the record. I'm fairly comfortable opening it up, moving around with H-J-K-L and editing here and there but I'm not much more productive than that.

Anyway, here's a short guide on how you too can get Emacs up and running on Version 2 of the [[https://docs.microsoft.com/en-us/windows/wsl/about][Windows for Linux subsystem]]

*** An optional prerequisite

Currently, I'm using [[https://x410.dev/][X410]], an [[https://en.wikipedia.org/wiki/X_Window_System][X Window System]] for Windows.

If you're not hugely familiar with X or Windowing systems, it's basically just a way of displaying applications outside of a terminal.

In our case, while Emacs renders perfectly fine in the terminal, I like to have it render in its own window, which is what a windowing system provides more or less.

There are plenty of other X servers for Windows but I found this one to be pretty seamless. [[https://sourceforge.net/projects/vcxsrv/][VcXsrv]] is another popular alternative, although I had some configuration troubles getting it working.

That said, I've done some fiddling and have provided a setup guide for it as well!

Before we get started, feel free to skip the entire window manager portion if you're comfortable with, or prefer, running Emacs in your terminal of course.

*** The paid, but pretty seamless way

I should stress that while I've opted to purchase an X server that has some extra bits and pieces, you can use an open source, unpaid alternative.

X410 had some decent recommendations for being an easy setup, and happened to be under a very steep discount so I figured I'd give it a spin. I also ran into some issues with VcXsrv originally as well.

You can find it [[https://www.microsoft.com/store/productId/9NLP712ZMN9Q][in the Windows Store]], presumably for any region. It'll require a Microsoft account to purchase which can be a little annoying if you don't already have one.

The installation should be straight forward and I don't remember any flags that require toggling.

Once you've got it installed, fire it up and you should see a silver X icon in your Windows task tray, in the bottom right of your screen.

You'll need to click on it (left or right, it makes no difference) and select "Allow Public Access". See the end of this section for a note on security.

While the original WSL1 exposes things on ~http://localhost~ (from memory anyway), WSL2 is treated like a network storage.

This means that our Linux distribution is effectively its own "computer" with its own IP address, and so firewall policies come into place, and so on.

When we connect to our X server, it'll be on an internal address such as 172.x.x.x rather than 127.0.0.1.

Beyond that, we should be good to go! You can either read the alternative setup or skip on down to configuring your ~DISPLAY~ environment variable.

Upon closer inspection, it seems that "Allow public access" does indeed do what it says on the tin.

I can confirm that I was able to forward an emacs session from my work laptop to my home desktop without any prompting. The same should hold true of any other random person on your network.

If you trust your network, and aren't proxying your computer to the internet or something interesting like that, you should be fine. In that case, feel free to jump down to the environment configuration section.

If you'd sleep safer at night with some tighter restrictions, feel free to follow the Windows Firewall configuration steps I've suggested below, under the setup for VcXsrv. They should apply exactly the same, but to the firewall rule for ~x410~.

*** The free, open source, slightly more involved way

For those of you who prefer to be able to either not pay for your software, or audit it, you'll want to pick up a copy of [[https://sourceforge.net/projects/vcxsrv/files/vcxsrv/][VcXsrv]].

It's a little more involved but not much more. I've gone through the gauntlet and figured out some settings that seem to work consistently while still staying relatively secure. That said, feel free to let me know since Windows Firewall isn't an area I tend to stray into often.

Go ahead and install ~VcXsrv~ and then once that's done, open up your start menu and search for ~XLaunch~.

If you run it, it should prompt you for some default settings. You can leave it set to the default (Multiple windows with the display number set to -1 for auto)

Extra settings should stay as the default.

You should get to a panel for extra parameters however, and when you do, you'll want to add ~-ac~ as a flag. Without it, you'll have some trouble down the line.

Upon finishing up this configuration, you should get a popup from Windows Defender Firewall. You can click Allow but we'll also do some further configuration next.

So, with XLaunch all wrapped up, head to your start menu once again and search for "Windows Defender Firewall with Advanced Security".

Open it up, click ~Inbound Rules~ and then scroll down until you find ~VcXsrv windows server~. You'll likely have about 4 entries, with two for TCP connections and another two for UDP connections.

Personally, I've opted to delete all of them except for one since I don't plan to keep a UDP configuration, nor do I need two types of TCP setup but you can leave them if you like.

You can either double click, or right click and hit properties, to start modifying your firewall rule.

First, under General, change the action to ~Allow the connection~ if it's not already set as such.

Don't worry, we'll be scoping down the permissions quite a bit. Well, as much as I could figure out how to anyway. I already did more fiddling here, for the sake of this post, than I probably would otherwise.

We don't want to allow just anyone to connect to our display server so under the ~Scope~ tab, I've added an IP address range.

Under ~Local IP Address~, select ~These IP addresses~, click ~Add~ -> ~This IP address range~ and then enter the following:

#+begin_src
From: 172.16.0.0
To  : 172.31.255.255
#+end_src

Given that the Windows subsystem is treated like a network device of sorts, our display server will essentially be receiving a connection from a different computer, as far as it's concerned.

In order to mitigate any actual other computers connecting, we're narrowing down the acceptable list of IP addresses to just those that fall within the WSL range.

I suppose if you did have a big internal network, with a computer assigned an address on 172.16.x.x, then they could connect but we'll be doing some interface restrictions just below.

Anyway, repeat the same steps for ~Remote IP address~ and then hit ~Apply your changes~.

At this point, what I wanted to do was reduce the scope of the ~Protocols~ tab to just TCP on the ports that X server uses (6000 - 6063) but I had no such luck.

It potentially be the case that somewhere between WSL land and your host computer, some ports are proxied to be higher or lower, but honestly, I'm purely speculating based on no actual evidence.

For the interested, the above protocol and port restriction causes the host X server to be unreachable. If you extend the range from 6000 to the highest possible port (65535), it does indeed connect which is why it seems it's relying on a range of ports higher than those 63 to be reachable.

Anyway, enough sidetracking. There is one extra bit of restricting we can do. Under ~Protocols and Ports~ -> ~Protocol type~, change it to just allow ~TCP~. You can then navigate to ~Advanced~ -> ~Interface types~ -> ~Customize~, and you should be able to narrow down the list to just ~Local area network~.

Presumably, even if anyone is on the wider network with an IP address that happens to match our WSL2 distro, they still won't be able to connect but I haven't tried this.

With all of that nonsense behind us, we can get on to actually configuring our environment and testing that our setup has worked successfully!

*** Configuring your environment

As I briefly referenced in the setup steps for X410, WSL2 is treated as a network device of sorts.

The exact details are besides the point here but just know that WSL2 is effectively a separate computer.

What this means, is that we can't rely on Emacs automatically knowing where to find our X display server (if you're opting to use one)

It'll check inside of our Linux distribution, but we need to point it to our Windows host, since that's where our X server is running.

Doing so is only one step thankfully:

#+begin_src
export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2; exit;}'):0.0
#+end_src

Ok, easy enough but what just happened?

By default, you'll have an ~/etc/resolv.conf~ generated by WSL. Here's what mine looks like on a relatively fresh installation:

#+begin_src
# This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:
# [network]
# generateResolvConf = false
nameserver 172.31.96.1
#+end_src

That IP address there, ~172.31.96.1~, is the IP address for our Window host machine. At least, from WSL's point of view anyway.

We can use ~grep~ to get the exact line we want:

#+begin_src
marcus@corbenik:~/code/utf9k$ cat /etc/resolv.conf | grep nameserver
nameserver 172.31.96.1
#+end_src

and then use ~awk~ to get just the IP address by itself:

#+begin_src
marcus@corbenik:~/code/utf9k$ cat /etc/resolv.conf | grep nameserver | awk '{print $2; exit;}'
172.31.96.1
#+end_src

Voila! One IP address. What our above command ends up evaluating to, is the following:

#+begin_src
export DISPLAY=172.31.96.1:0.0
#+end_src

That IP address can change from time to time however, which is why we want to automate setting it each time.

Our ~DISPLAY~ environment variable will go away with each new shell so make sure you put it in your shell startup!

All that's let is to check that we can connect as expected. Here's a connection test against X410, using ~nc~ (netcat)

#+begin_src
marcus@corbenik:~/code/utf9k$ nc -v 172.31.96.1 6000
Connection to 172.31.96.1 6000 port [tcp/x11] succeeded!
#+end_src

Why do we use port 6000? It's the first in a range of ports for X window servers, which range from 6000 - 6063. If you note the ~0.0~ on the end of our ~DISPLAY~ variable, we're telling it to use display 0, screen 0.

If we wanted to use a different display, or perhaps having a second X server may qualify, we could connect to ~<address>:1.0~ for display 1, screen 0. Under the hood, that would live on port 6001, which is the base port of 6000 added to our display number (1 in this case).

I didn't really know any of that until writing this so I'd encourage you to do your own research if you want to know more, or double check anything I just claimed, haha.

*** Installing Emacs

Now then, we need an actual Emacs distribution but don't get too trigger happy just yet. For the most part, running ~sudo apt-get install emacs~ will give you an outdated package. In reality, it's probably Emacs 25 which is more than fine.

If you'd like to run a more up to date version, you can do the following to fetch a copy of Emacs 26. If you'd like to be on the bleeding edge (and is what Doom Emacs recommends), you'll probably need to compile Emacs 27 from source :(

#+begin_src
sudo add-apt-repository ppa:kelleyk/emacs
sudo apt-get update
sudo apt-get install emacs26
#+end_src

Very nice, you should be all good to go. If you'd like to use Doom Emacs as I am, you'll need some extra packages which you can find more info about [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#ubuntu][via the handy documentation]]

If you'd like to run Emacs in your terminal, just simply fire up ~emacs~. If you'd like to run it on your Windows host, and have your X server running and set up, you can run ~emacs &~ to spawn it, and keep it open as a background process.

Happy text manipulation!

P.S. I wrote this entire post in Doom Emacs, launched from WSL 2 on my home desktop and it works like a charm :)

** 25 :meta:
:PROPERTIES:
:EXPORT_FILE_NAME: 25
:EXPORT_DATE: 2019-08-19
:END:

It's 6:30pm on my 25th birthday and I've been reflecting a bit on what I've managed to accomplish so far. While this isn't a post about that, there's no better time to assess the state of my personal site and where I'd like to go forward.

*** The current state

At present, my blog isn't really best effort. I'd like to write more things but I never really make it an actual goal. I'd say the biggest reason is that I've been wrapped up in work side projects instead of my own personal side projects so I'll be looking to stop doing that.

My site has gone through plenty of iterations, with the current being a static site, built with Hugo and hosted on Netlify. It works but it's not exactly how I'd like it.

Along the way, pages have disappeared. There used to be a projects page which never got filled in properly. There was also an archive of reviews I wrote years back. They're still there but not publically exposed anywhere.

## Where I'd like to get to

I always seem to fumble around a lot with Markdown. It works great but there's always things missing I wish I had. Some markdown libraries support tables while some don't, or defer to extensions.

I've come across Asciidoc recently and it seems to be exactly what I'd like. Even as a general document format, it seems pretty handy.

Hugo does have support for it, but it runs with some hardcoded flags that are annoying. It requires a Hugo heading block so you might get a mix like so:

#+begin_src bash
---
title: 25
date: 2019-08-19
tags: [meta]
---

= 25
Marcus Crane <marcus@utf9k.net>
v1.0, 2019-08-19

It's 6:30pm...
#+end_src

This works fine but I'd like to stick to just one single format. Mixing metadata just for Hugo and metadata just for Asciidoc is annoying so I'll have a look into that. Asciidoc itself provides pretty much everything I'd want out the box for a static site. The remainder is just building the category pages and so on, which I don't necessarily need a fully fledged framework for.

*** Some topics I'd like to look into

I've got a list of topics I sometimes keep handy but I haven't invested much time into exploring.

Off the top of my head, there's some stuff I'd like to write about and others I'd have to research. In no particular order:

- A writeup of all the iterations of my site with pros and cons (eg; Django, Flask, Hugo, Jekyll etc)
- A comparison of "Prepay SMS UIs"
  - A little while ago I changed cell providers (and then switched back). Topping up credit using SMS based menus was fascinating since it's like this whole web.
  - It'd be interesting to model the various states you can get into and just talk about text based UIs in general
  - Perhaps there'd be some lessons from there that could be reused in chat based UIs or whatever the flavour of the month is with Slack.
- Donating to those who are homeless / on the streets in the future
  - With plenty of things moving to Paywave type technology, what will happen?
  - Personally, I rarely/never carry cash on me anymore so I couldn't give spare change even if I wanted
- My own personal de-googlify post
  - I recently deleted my Google account after finding a replacement for YouTube (exported my subscriptions as an RSS feed)
  - Most other services I had a replacement for, or never used them.
  - Currently running LineageOS with a custom location provider so pretty much no reliance on Google stuff for Android
  - One missing piece then I'd be ready to write about how it's worked for (quite well actually)
  - I'm not hardline "my freedoms" so I still run eg; Instagram and what not. The idea isn't to be pure but find a balance between convenience and privacy (as much as that's a thing hah)
- Github vs Gitlab
  - I recently imported some stuff to Gitlab. I haven't invested much time into it but it seems promising given how many features they've developed.
  - They could all just be quite shallow and not very reliable however.
- Reducing my "every day carry"
  - I recently managed to merge my keys, cards and public transport tag into one which has been working quite well
  - I'd always fancied the idea of not having a wallet but couldn't really see how it would work
- Picking mediums
  - Us humans seem to be bad at picking mediums. We do tweetstorms about political policy or complex issues rather than doing long form.
  - In some cases, shorter mediums are popular but the medium itself shapes the content
  - To fit eg; Twitter's message size, you're going to simplify ideas as much as you can (but no more) but nuance may get lost in the process.

*** Other things to add

- A proper projects page
  - I've got some stuff I can probably put up but it would also give me a reason to focus on personal projects more
- Bring back the reviews page
  - I'd like to have something (automation idk) embed cover art and what not for reviews so they look a bit more official
- Perhaps a stats page
  - I used to have this at one point which would pull information from various places
  - It was a nice excuse to play around with technology I wasn't familiar with like Redis or Celery queues
- Setting the whole dynamic vs static thing
  - Part of me wants to go back to dynamic all the time as an excuse to learn new technologies
  - Maybe a mix of the two is would suit me best. Just use asciidoc (via a subprocess) to render pages / store them statically while dynamically building the list type pages

*** How do I get there

I just gotta start leaving my laptop at work or else I get tempted to work on work technologies honestly. None of the above is hard but it's easy to get side tracked or want to finish off something.

In this case, there's no requirement for me to do so. Things just happen to cross over with my interests.

Anyway, this post is me committing to changing that, and also having a list of things to look into before I forget.

Perhaps we'll do a 26 this time next year. On that note.

*** Some final thoughts

- This site is essentially my portfolio but I don't care to make it particularly professional. The style is "Things past me would enjoy stumbling upon".
- While there may be some posts about specialised topics, none of them should be sacred and should attempt to be readable by anyone.
  - There's that scale that tells you if text is at a 3rd grade reading level etc. That could be an interesting thing to run over some posts.
- I rarely look at analytics. They don't have any bearing on what I write. Comments I don't mind but they're not really integrated well. Maybe I'll get rid of them.
- I'd like the site to be a bit more nice to look at. I tried the whole dark scheme for a bit and it's good but not quite perfect. Maybe I even support both?
- Reference books seem to have some cool layouts. I could probably pull some inspiration from them.
- I think I've fallen out of love with menus. If I do have then, breadcrumb style things might be a way to go.
- I'd like to look back in a few years and see a bunch of stuff that reflects who I was, and how much I know, at that point in time. That's partly why having a format that lasts is important since Hugo may disappear one day for all I know.

Thanks for reading

** Recovering lost python results in the REPL :python:snippet:
:PROPERTIES:
:EXPORT_FILE_NAME: lost-python-results
:EXPORT_DATE: 2018-12-12
:END:

I was messing around with some queuing earlier today in order to try out the [[https://github.com/celery/kombu][Kombu]] library. It works pretty nicely but I goofed up while playing with it.

To add a message to a queue, it looks a little like this:

#+begin_src python
from kombu import Connection, Queue

conn = Connection() # Defaults to a RabbitMQ Docker container I have running locally
queue = conn.SimpleQueue('test')
queue.put('this is a message i want to put on the queue')
#+end_src

You may want to use a context manager instead but for a simple test, this works fine. Now then, how about getting a message off the queue? It's straight forward as well.

#+begin_src python
queue.get()
# <Message object at 0x110a844c8 with details {'state': 'RECEIVED', 'content_type': 'text/plain', 'delivery_tag': 1, 'body_length': 5, 'properties': {}, 'delivery_info': {'exchange': 'test', 'routing_key': 'test'}}>
#+end_src

Cool, we've received a message now so next we need to acknowledge it with the ack function...

Wait a minute, we forgot to save that message to a variable so how the hell can we acknowledge it?! Damn, it's totally just lost in memory, huh?

This is a scenario I ran into and it got me wondering: Is it possible to retrieve a Python object by that hex/memory address? Well, it turns out that you can't. I haven't done a deep dive yet but if it's a continuously running application, it may soon exit memory and be lost forever.

If you're just running in the Python REPL however, there is actually a way: The handy ~_~ operator.

#+begin_src python
# <Message object at 0x110a844c8 with details {'state': 'RECEIVED', 'content_type': 'text/plain', 'delivery_tag': 1, 'body_length': 5, 'properties': {}, 'delivery_info': {'exchange': 'test', 'routing_key': 'test'}}>
_.ack()
# <Message object at 0x110a844c8 with details {'state': 'ACK', 'content_type': 'text/plain', 'delivery_tag': 1, 'body_length': 5, 'properties': {}, 'delivery_info': {'exchange': 'test', 'routing_key': 'test'}}>
message = _
print(message)
# <Message object at 0x110a844c8 with details {'state': 'ACK', 'content_type': 'text/plain', 'delivery_tag': 1, 'body_length': 5, 'properties': {}, 'delivery_info': {'exchange': 'test', 'routing_key': 'test'}}>
#+end_src

As you can see, the interpreter actually binds the last result to the ~_~ character. If you were to do ~1 + 1~, the value of ~_~ would be 2! You can also bind the value to a variable for use later on.

I don't think I'd need it often but it's very handy to know.
** When automation goes horribly right :automation:microservices:twitter:
:PROPERTIES:
:EXPORT_FILE_NAME: automation-right
:EXPORT_DATE: 2018-12-03
:END:

Today, I finally solved an issue that has been a pain in my ass for many months: successful automation

Towards the latter end of 2016, Twitter announced a new suite of tools for businesses via a [[https://blog.twitter.com/marketing/en_us/topics/product-news/2016/speed-up-customer-service-with-quick-replies-welcome-messages.html][blog post]]. There were a bunch of things from quick replies to profile-listed support hours which I'm sure were of some use.

I used the latter but I also enabled "welcome messages": automated replies that would trigger when a "customer" opened your direct messages. In my case, I'm not a business so it was more just some silliness to add to my profile and it confused a few people along the way.

[[./img/automation-right/confusion-one.png]]

Over time, I'd forget that I had it enabled and then someone else would get caught out by it a few months later

[[./img/automation-right/confusion-two.png]]

and then it kept going at which point it started becoming a bit of a nuisance.

[[./img/automation-right/confusion-three.png]]

At this point, I was particularly annoyed and attempted to turn it off. I clearly remembered that there was a dashboard but do you think I could find it? That would be too easy!

You can actually see a walkthrough of that very page right [[https://youtu.be/H-n0hRO7oLk?t=75][here]] but good luck finding it because it was actually removed.

At first I didn't believe it. I just figured I had forgotten how to navigate to it but every month, I'd try once again to track it down with no luck. Eventually, I just resigned myself to the fact that some automation was running somewhere inside Twitter and I could never turn it off.

Things changed. I started a new job as a Site Reliability Engineer funnily enough. I would laugh to myself whenever we discussed service availability. Inevitably, it would come up that Google has planned outages in order to keep downstream providers on their toes and not overly reliant.

I wished so hard that Twitter would have a planned outage but no, apparently this microservice, or whatever it was, never failed. It was perfect and never toppled. Seriously, give those developers a pat on the back because I wanted nothing more than to take a baseball bat to the entire fucking cloud.

Obviously I couldn't just simply call Twitter and ask them.

Fast forward to today and once more, a confused friend simply messaged me "?". I didn't even have to ask. Whatever this automation was, it never really seemed consistent either. Those who I talked to often would suddenly receive an automated response out of nowhere. Not that I could tell since it wasn't me talking.

Finally I stumbled onto the Twitter Developer forum and... ah! [[https://twittercommunity.com/t/defunct-business-auto-dm-feature-no-longer-editable-and-still-sends/116561][I wasn't alone!]] I'm not crazy! Someone else remembers this thing!

After a bit of confusion, it was cleared up that the Twitter API has a section for "welcome messages" which are these very same automated snippets. Using [[https://github.com/twitter/twurl][twurl]], a Twitter-modified version of curl, I could view those darn things finally.

[[./img/automation-right/welcome-messages.png]]

There they were. Sitting within the API the whole time although I'd guess that feature was only documented as part of the recent overhaul of Twitter's developer APIs. Even the original URL, [[https://dashboard.twitter.com][dashboard.twitter.com]], doesn't resolve anymore which is all the proof I needed that I'd been left out in the cold.

With some copy paste magic, I quickly wiped the slate clean. I was free!

Finally awake from that god awful nightmare.

The Twitter Business Experience was definitely just that...

That just leaves one last question: if it took me many months to fix this problem, what hope do those actual businesses who signed up have?

I guess you get the support you pay for, huh?
